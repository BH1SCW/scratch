#include "fsm2.h"

//======================================================================================================================
FsmContext::FsmContext() : top_level_fsm_(nullptr)
  //======================================================================================================================
{
}

//----------------------------------------------------------------------------------------------------------------------
void FsmContext::setTopLevelFsm(Fsm* top)
//----------------------------------------------------------------------------------------------------------------------
{
  top_level_fsm_ = top;
}

//----------------------------------------------------------------------------------------------------------------------
void FsmContext::trigger(const FsmSignal& signal)
//----------------------------------------------------------------------------------------------------------------------
{
  top_level_fsm_->trigger(signal);
}

//======================================================================================================================
Fsm::Fsm(FsmContext& ctx, const std::string& name) : is_init_(false), context_(ctx), name_(name)
//======================================================================================================================
{
}

//----------------------------------------------------------------------------------------------------------------------
Fsm::~Fsm()
//----------------------------------------------------------------------------------------------------------------------
{}

//----------------------------------------------------------------------------------------------------------------------
void Fsm::onEntry()
//----------------------------------------------------------------------------------------------------------------------
{}

//----------------------------------------------------------------------------------------------------------------------
void Fsm::onExit()
//----------------------------------------------------------------------------------------------------------------------
{}

//----------------------------------------------------------------------------------------------------------------------
void Fsm::addState(std::shared_ptr<Fsm> state)
//----------------------------------------------------------------------------------------------------------------------
{
  states_.emplace_back(std::move(state));
}

//----------------------------------------------------------------------------------------------------------------------
void Fsm::addTransitionRule(const std::string& state, const FsmSignal& signal, const std::string& new_state)
//----------------------------------------------------------------------------------------------------------------------
{
  /// \todo
  /// - 3 params of same type => potential for error
  /// - check old and new states are present
  transitions_.push_back({state, new_state, signal});
}

//----------------------------------------------------------------------------------------------------------------------
void Fsm::initialise(const std::string& initial_state)
//----------------------------------------------------------------------------------------------------------------------
{
  const auto it_end = states_.end();
  if(is_init_)
  {
    (*current_state_it_)->onExit();
  }
  auto it = std::find_if(states_.begin(), states_.end(), [&initial_state](const std::shared_ptr<Fsm>& state){return state->name_ == initial_state; });
  if(it == it_end)
  {
    throw std::runtime_error("No such state");
  }
  current_state_it_ = it;
  is_init_ = true;
}

//----------------------------------------------------------------------------------------------------------------------
std::shared_ptr<Fsm> Fsm::getCurrentState()
//----------------------------------------------------------------------------------------------------------------------
{
  /// \todo
  /// - what happens to current_state_it_ when new states are added. does it get invalidated?

  if(current_state_it_ == states_.end())
  {
    return nullptr;
  }
  return *current_state_it_;
}

//----------------------------------------------------------------------------------------------------------------------
bool Fsm::trigger(const std::string& signal)
//----------------------------------------------------------------------------------------------------------------------
{
  // pass signal down the current state and see if it gets consumed there
  if((*current_state_it_)->is_init_)
  {
    if((*current_state_it_)->trigger(signal))
    {
      return true;
    }
  }

  // find a valid transition
  const auto it = std::find_if(transitions_.begin(), transitions_.end(), [this, signal](const FsmTransition& t)
  {
    return (t.current_state == (*current_state_it_)->name_) && (t.signal == signal);
  });

  if(it == transitions_.end())
  {
    return false;
  }

  // find next state
  auto next_state = std::find_if(states_.begin(), states_.end(), [it](const std::shared_ptr<Fsm>& fsm)
  {
    return fsm->name_ == (*it).new_state;
  });
  if(next_state == states_.end())
  {
    return false;
  }

  // exit current state and bring up new state
  (*current_state_it_)->onExit();
  current_state_it_ = next_state;
  auto fut = std::async(std::launch::async, [this](){(*current_state_it_)->onEntry();});
  pending_futs_.emplace_back(std::move(fut));

  /// \todo - pending_futs_ needs to be cleared

  return true;
}

//----------------------------------------------------------------------------------------------------------------------
FsmContext& Fsm::getContext()
//----------------------------------------------------------------------------------------------------------------------
{
  return context_;
}

//----------------------------------------------------------------------------------------------------------------------
std::string Fsm::name()
//----------------------------------------------------------------------------------------------------------------------
{
  return name_;
}
